// CSE 240 Assignment 4 (Critters)
// Author: Kelly Wilkerson

// Adapted from University of Washington's CSE 142 Critters in Java
// by Marty Stepp and Stuart Reges
// -and-
// University of California San Diego's CSE 8B Critters in Java
// by Mike Stepp
// 
// This adaptation strips down a lot of the critter complexity to present
// a short-and-sweet assignment in C++ about implementing a few classes
// using inheritance and then seeing the objects of those classes being
// used in a homogeneous manner with dynamic dispatch.
//
// This adaptation of the assignment also introduces the best critter
// of them all, your Sun Devil!

// This class defines the methods necessary for an animal to be part of the simulation.
// Your critter animal classes 'extend' this class to add to its basic functionality.
//
// DO NOT EDIT THIS FILE
//

#ifndef CRITTER_H
#define CRITTER_H

#include <cstdlib>   // for srand and rand
#include <iostream>

#define EMPTY_NEIGHBOR ' '

// ---------------------- direction stuff -------------------------

// Because we are using the value of the direction as an access into
// an array in setNeighbor, we give define the int value of the
// enumeration values so that it works out nicely.
typedef enum Direction_t {
    NORTH = 0,
    SOUTH = 1,
    EAST = 2,
    WEST = 3
} Direction;

#define NUM_DIRECTIONS 4

// a function you might need to call to get a random direction
Direction randomDirection();

// ---------------------- end direction stuff ----------------------

// ---------------------- fighting stuff ---------------------------
// constants for choice of fighting strategy
typedef enum Attack_t {
    ROAR, POUNCE, SCRATCH, FORFEIT
} Attack;

// ---------------------- end fighting stuff ------------------------

class Critter {
    
 public:
    Critter();
    virtual ~Critter();

    /* The following three methods are the ones you'll be implementing
       for your assignment.  I'm not going to comment them because you
       should in your own implementations.  Note that two of these
       functions are "pure virtual" functions; they have no
       implementation.  Because the Critter class has at least one
       pure virtual function, we say that the Critter class is
       abstract.
    */
    virtual Attack fight(char opponent)=0;
    virtual Direction getMove()=0;
    virtual char getChar();

 protected:
    /* The following methods are provided in case you wanted to get
       information about your critter. */

    // (Technically the critter could call setXxxx() on itself,
    // but the game model ignores this anyway, so it's useless to do so.)
    // These methods are not declared virtual so you can't override them.
    unsigned int  getHeight();
    unsigned int  getWidth();
    unsigned int  getX();
    unsigned int  getY();
    char getNeighbor(Direction);
    bool isAlive();

 public:
    /* These methods are provided to inform you about the events
     happening to your critters.  You can override these methods in
     your SunDevil to be informed of these events if you wanted to. */
    
    // called when you win a fight against another animal
    virtual void win() {}
    
    // called when you lose a fight against another animal, and die
    virtual void lose() {}

    // called when your critter is about to move and possibly fight.
    virtual void beginTurn() {}

    // called when your critter is done moving and possibly fighting.
    virtual void endTurn() {}
    
 private:
    /* I use these fields to implement the methods below such as getX
     and getNeighbor.  They are private so you cannot manipulate them
     directly in your critters. */
    unsigned int x;
    unsigned int y;
    unsigned int width;
    unsigned int height;
    bool alive;
    char *neighbors;
    bool mark;


 public:
    // The game model uses these to update the state of your critter
    // so that you can ask about it if you wanted to.
    void setAlive(bool);
    void setHeight(unsigned int);
    void setWidth(unsigned int);
    void setX(unsigned int);
    void setY(unsigned int);
    void setNeighbor(Direction, char);
    
    // used by the game model to make sure we don't move someone twice!
    void setMark() { mark = true; }
    void clearMark() { mark = false; }
    bool hasGone() { return mark; }
  
    // used by your simple testing program to verify the objects
    // behave as described
    void printBehavior();
};


#endif
